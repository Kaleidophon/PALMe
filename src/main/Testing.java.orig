package main;

import inout.*;
import inout.general.DataLoader;
import inout.indexing.BinaryIndexing;
import inout.indexing.HexadecimalIndexing;
import inout.indexing.Indexing;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;

<<<<<<< HEAD
import utilities.eval.Evaluation;
import languagemodel.calc.ProbabilityCalculation;
import languagemodel.model.LanguageModel;

public class Testing {
	
	public static void createTestData(int n) {
=======
public class Testing {

	public static void main(String[] args) {
		createTestData(3);
		createTestData(4);
		createTestData(5);
		/*int n = 5;
		for (int c = 0; c <= 5; c++) {
			timeIndexing(c, "./rsc/indices/" + n + "/", false, 10);
			timeIndexing(c, "./rsc/indices/" + n + "/", true, 10);
		}*/
	}
	
	private static void createTestData(int n) {
>>>>>>> b4ae5c7f964eb37cd72430c8439f8b45ec1664e1
		List<Indexing> indexings = new ArrayList<>();
		System.out.println("Reading frequencies...");
		DataLoader dl = new DataLoader("./rsc/freqs/" + n + "/res.txt");
		Map<String, Integer> freqs = dl.readFrequencies();
		indexings.add(new Indexing<Integer>());
		indexings.add(new BinaryIndexing<Integer>());
		indexings.add(new HexadecimalIndexing<Integer>());
		
		for (Indexing indexing : indexings) {
			if (indexing instanceof BinaryIndexing) {
				System.out.println("Create new "  + indexing.getClass().getName() + " for n = " + n);
				indexing = new BinaryIndexing(freqs, "./rsc/indices/", "./rsc/indices/lexicons/lexicon.gz");
				System.out.println(indexing.getClass().getName());
			} else if (indexing instanceof HexadecimalIndexing) {
				System.out.println("Create new "  + indexing.getClass().getName() + " for n = " + n);
				indexing = new HexadecimalIndexing(freqs, "./rsc/indices/", "./rsc/indices/lexicons/lexicon.gz");
				System.out.println(indexing.getClass().getName());
			} else if (indexing instanceof Indexing) {
				System.out.println("Create new "  + indexing.getClass().getName() + " for n = " + n);
				indexing = new Indexing<Integer>(freqs, "./rsc/indices/", "./rsc/indices/lexicons/lexicon.gz");
				System.out.println(indexing.getClass().getName());
			}
			System.out.println("Dumping...");
			indexing.dump("./rsc/indices/", false);
			indexing.dump("./rsc/indices/", true);
			indexing = null;
			//dl.dumpIndexing(indexing, "./rsc/indices/" + n + "/", true);
		}
	}
	
<<<<<<< HEAD
	public static <V extends Number> void timeIndexingLoading(int mode, String IN_PATH, String LEX_PATH, boolean zipped, int iterations, int threads) {
=======
	private static void timeIndexing(int mode, String IN_PATH, String LEX_PATH, boolean para, int iterations) {
>>>>>>> b4ae5c7f964eb37cd72430c8439f8b45ec1664e1
		System.out.println("Path: " + IN_PATH + " | Mode: " + mode);
		DataLoader dl = new DataLoader();
		long[] durations = new long[iterations];
		String experiment_name = "";
		
		switch(mode) {
			case(0): 
<<<<<<< HEAD
				experiment_name = (zipped) ? "Timing zipped Indexing loading" : "Timing unzipped Indexing loading"; 
				break;
			case(1): 
				experiment_name = (zipped) ? "Timing zipped Binary Indexing loading" : "Timing unzipped Binary Indexing loading"; 
				break;
			case(2): 
				experiment_name = (zipped) ? "Timing zipped Hexadecimal Indexing loading" : "Timing unzipped Hexadecimal Indexing loading"; 
				break;
		}
		
		if (threads > 1) experiment_name = experiment_name.substring(0, 6) + " parallelized" + experiment_name.substring(7, experiment_name.length());
		
		for (int i = 0; i < iterations; i++) {
			System.out.println("Starting iteration #" + (i+1) + "...");
			long startTime = System.nanoTime();
			switch (mode) {
				case (0):
					Indexing<V> indexing1 = null;
					if (threads > 1) {
						indexing1 = new Indexing<>(LEX_PATH, IN_PATH, zipped, threads);
					} else {
						indexing1 = new Indexing<>(LEX_PATH, IN_PATH, zipped);
					}
					break;
				case (2):
					Indexing<V> indexing2 = null;
					if (threads > 1) {
						indexing2 = new BinaryIndexing<>(LEX_PATH, IN_PATH, zipped, threads);
					} else {
						indexing2 = new BinaryIndexing<>(LEX_PATH, IN_PATH, zipped);
					}
					break;
				case (3):
					Indexing<V> indexing3 = null;
					if (threads > 1) {
						indexing3 = new HexadecimalIndexing<>(LEX_PATH, IN_PATH, zipped, threads);
					} else {
						indexing3 = new HexadecimalIndexing<>(LEX_PATH, IN_PATH, zipped);
					}
=======
				experiment_name = (para) ? "Loading zipped Indexing" : "Loading unzipped Indexing"; 
				break;
			case(1): 
				experiment_name = (para) ? "Loading zipped Binary Indexing" : "Loading unzipped Binary Indexing"; 
				break;
			case(2): 
				experiment_name = (para) ? "Loading zipped Hexadecimal Indexing" : "Loading unzipped Hexadecimal Indexing"; 
				break;
			case(3): 
				experiment_name = (para) ? "Loading validated serialized Indexing" : "Loading unvalidated serizalied Indexing"; 
				break;
			case(4):
				experiment_name = (para) ? "Loading validated serialized Binary Indexing" : "Loading unvalidated serizalied Binary Indexing"; 
				break;
			case(5): 
				experiment_name = (para) ? "Loading validated serialized Hexadecimal Indexing" : "Loading unvalidated Hexadecimal Indexing"; 
				break;
		}
		
		for (int i = 0; i < iterations; i++) {
			long startTime = System.nanoTime();
			switch (mode) {
				case (0):
					Indexing<Integer> indexing1 = new Indexing<>(LEX_PATH, IN_PATH, para);
					break;
				case (2):
					Indexing indexing2 = new BinaryIndexing(LEX_PATH, IN_PATH, para);
					break;
				case (3):
					Indexing indexing3 = new HexadecimalIndexing(LEX_PATH, IN_PATH, para);
					break;
				case (4):
					//Indexing<Integer> indexing4 = dl.loadIndexing(IN_PATH + "index.ser", para);
					break;
				case (5):
					//Indexing indexing5 = dl.loadIndexing(IN_PATH + "bin_index.ser", para);
					break;
				case (6):
					//Indexing indexing6 = dl.loadIndexing(IN_PATH + "hex_index.ser", para);
>>>>>>> b4ae5c7f964eb37cd72430c8439f8b45ec1664e1
					break;
			}
			long endTime = System.nanoTime();
			long duration = (endTime - startTime);
			durations[i] = duration;
<<<<<<< HEAD
			System.out.println("Iteration #" + (i+1) + " took " + duration + " s.");
		}
		System.out.println(experiment_name + " took " + average(durations) / 1000000000.0 + " seconds on average.");
	}
	
	public static void timeProbabilityCalculation(int n, String IN_PATH, ProbabilityCalculation prob_calc, int iterations) {
		testProbabilityCalculationTime(n, IN_PATH, prob_calc, 0, 0, iterations);
	}
	
	public static void testProbabilityCalculationTime(int n, String IN_PATH, ProbabilityCalculation prob_calc, int producer, int consumer, int iterations) {
		LanguageModel lm = new LanguageModel(n, IN_PATH, prob_calc, "fast back-off", true);
		long[] durations = new long[iterations];
		String experiment_name = (producer == 0 && consumer == 0) ? "Default " : "Parallelized ";
		experiment_name += "language model probability calculation";
		
		for (int i = 0; i < iterations; i++) {
			System.out.println("Starting iteration #" + (i+1) + "...");
			long startTime = System.nanoTime();
			if (producer == 0 && consumer == 0) {
				lm.calculate();
			} else {
				lm.calculateParallelized(producer, consumer);
			}
			long endTime = System.nanoTime();
			long duration = (endTime - startTime);
			durations[i] = duration;
			System.out.println("Iteration #" + (i+1) + " took " + duration + " s.");
		}
		System.out.println(experiment_name + " took " + average(durations) / 1000000000.0 + " seconds on average.");
	}
	
	public static void timeLanguageModelEvaluation(int n, String IN_PATH, String mode, String TEST_INPATH, int producer, int consumer, int iterations) {
		LanguageModel lm = new LanguageModel(n, IN_PATH,"fast back-off", true);
		long[] durations = new long[iterations];
		String experiment_name = (producer == 0 && consumer == 0) ? "Default " : "Parallelized ";
		experiment_name += "language model evaluation";
				
		for (int i = 0; i < iterations; i++) {
			System.out.println("Starting iteration #" + (i+1) + "...");
			long startTime = System.nanoTime();
			if (producer == 0 && consumer == 0) {
				Evaluation.evaluateLanguageModel(lm, TEST_INPATH);
			} else {
				Evaluation.evaluateLanguageModelParallelized(lm, TEST_INPATH, producer, consumer);
			}
			long endTime = System.nanoTime();
			long duration = (endTime - startTime);
			durations[i] = duration;
			System.out.println("Iteration #" + (i+1) + " took " + duration + " s.");
=======
>>>>>>> b4ae5c7f964eb37cd72430c8439f8b45ec1664e1
		}
		System.out.println(experiment_name + " took " + average(durations) / 1000000000.0 + " seconds on average.");
	}
	
	private static double average(long[] a) {
		long sum = 0;
		for (long e : a) {
			sum += e;
		}
		return sum * 1.0 / a.length;
	}
}
